---
title: Progress for Sep. 8
tags: MyConbook,databases,iOS,Android
date: September 8, 2012
---
<img src="assets/2012-09-08-progress-for-sep-8.png" class="img-fluid">

This is how the app looks so far. I didn’t have too much time to work on it today, kept getting distracted and finally got to head out to Hacker Dojo at about 8:30PM. Was hoping to get a key, but wasn’t able to yet, unfortunately, will try again later this week.

Anyway, I figure I’ve done enough with the UI (general layout) that I need to start being able to make it actually do things by pulling in the data.

Unfortunately, compared to Android, iOS has no real developer-friendly support for talking to databases. Core Data works if you’re maintaining your own data (which is usually the case, but not for MyConbook) but otherwise you have to use the native sqlite3 library, which means calling into C code. On Android, this is accomplished much more easily with the [SQLiteDatabase class](https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html) and [cursors](https://developer.android.com/reference/android/database/Cursor.html), then it can be presented as a [content provider](https://developer.android.com/guide/topics/providers/content-providers.html) to be consumed with a wonderful new feature in Android 3 called a [Loader](https://developer.android.com/guide/components/loaders.html). MyConbook uses this method on Android to present data to the UI without accessing the data source directly.

Back to iOS, fortunately there is already an Objective-C wrapper for SQLite called [FMDB](https://github.com/ccgus/fmdb). I plan on using this for the iOS version. But since we have to deal with the database more or less directly, I’ll be writing a bunch of code to access the data. It will end up working similarly to a read-only ORM (we don’t write back to the sqlite DB). There will be a bunch of boiler code but I’m going to try and use inheritance as much as I can to keep it from getting too messy.

Basically, there will be a class for each “row”, which will contain a function to read the content of the row from the database and populate itself. The goal is to only read what data is nessicary in order to reduce data access times when trying to build the UI. Pulling in the entire table is much slower than reading a single row when that’s all you need. TableRows in iOS load on demand, so we can asyncornously load and display a row. Load from the database, parse the result and put it into an object, which is then bound to the UI view. Not too difficult!

It would be a lot nicer if there were ORMs written for iOS, but to be honest most of the time you’d be using Core Data anyway. I made a weird use case by having the application download a pre-built SQLite database from a server. If I wanted to tackle this a little differently (and I’ll probably have to in the future if I decide to support incremental data updates) I’d download a JSON file from the server instead, then dump that content into a local Core Data structure. Core Data uses SQLite anyway, but it’s used transparently, and only shows the developer the ORM side. This would be convienient but I’m going to try and keep the current route I’ve been using for the other version in order to avoid parsing JSON on iOS (which is another pain). As a note, a JSON structure is already being generated for the web version, at the same time as the SQLite database, so there’s no reason it couldn’t be used instead. I just don’t see it being easier than the database to use on device, especially when we need to do things like searches.

Originally, the Android version loaded the entire database into an object structure when it first started. I don’t remember if it ever worked that way once it was released, but there was an actually fair amount of exploration that went on in the month or so I had before the first convention where the app would get used. It was originally written before the Loader API was released, and fortunately most new Android features that don’t use something built into the core are backwards compatible either by using the [Android Support Library](https://developer.android.com/topic/libraries/support-library), or just copying the code out of the repository and putting it into yours. Both loaders and the Action Bar (with the help of [ActionBarSherlock](http://actionbarsherlock.com/)) are both handled this way to work on lower Android versions in MyConbook.

So, this is probably as far as I’ll get today. I have an idea how I want to structure the database, and I’ve written up most of how it’s going to get done. The next time I get back to work on this (maybe tomorrow, with any hope) I’ll probably spend the time writing out the classes and the code the handle converting the SQLite results into objects. I’ve spent most of this post writing up how that works, anyway, so I’ll probably get more into the actual code and structure next time.
